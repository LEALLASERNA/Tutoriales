La **herencia** permite que un contrato herede el comportamiento (funciones y estado) de otro contrato. Esto es útil cuando quieres construir contratos más complejos basados en contratos más simples, reutilizando su lógica.

En Solidity, un contrato puede heredar de uno o más contratos, y esto permite compartir funcionalidad entre contratos.

## Herencia básica ##

Para hacer que un contrato herede de otro, simplemente se usa la palabra clave `is`. El contrato "hijo" hereda todo el estado (variables) y las funciones del contrato "padre".

```javascript
pragma solidity ^0.8.0;

contract Padre {
    string public nombre = "Contrato Padre";
    
    function decirHola() public pure returns (string memory) {
        return "Hola desde el Contrato Padre";
    }
}

contract Hijo is Padre {
    // Este contrato ahora tiene acceso a la variable 'nombre' y a la función 'decirHola' del contrato Padre
}
```
En este ejemplo, el contrato `Hijo` tiene acceso a todo lo que está en el contrato `Padre`, es decir, la variable `nombre` y la función `decirHola`.

### Constructores y herencia ###

Cuando un contrato hereda de otro, es posible que el constructor del contrato padre también deba ser llamado. Esto se hace desde el constructor del contrato hijo.

```javascript
pragma solidity ^0.8.0;

contract Padre {
    string public nombre;

    constructor(string memory _nombre) {
        nombre = _nombre;
    }
}

contract Hijo is Padre {
    constructor(string memory _nombre) Padre(_nombre) {
        // El constructor de Hijo llama al constructor de Padre
    }
}
```
En este ejemplo, el constructor del contrato `Padre` se llama desde el constructor de `Hijo`, pasando el argumento `_nombre` al padre.

### Sobrescribir funciones

Si un contrato hijo necesita cambiar el comportamiento de una función que ha heredado, puede **sobrescribir** esa función. Para hacerlo, se usa la palabra clave `override`.

```javascript
pragma solidity ^0.8.0;

contract Padre {
    function decirHola() public pure virtual returns (string memory) {
        return "Hola desde el Contrato Padre";
    }
}

contract Hijo is Padre {
    function decirHola() public pure override returns (string memory) {
        return "Hola desde el Contrato Hijo";
    }
}
```
En el contrato `Padre`, la función `decirHola` está marcada como `virtual`, lo que significa que puede ser sobrescrita.
En el contrato `Hijo`, la función `decirHola` es sobrescrita usando la palabra clave `override`, cambiando su comportamiento.

## Herencia múltiple

En Solidity, un contrato puede heredar de múltiples contratos. Cuando haces esto, debes tener cuidado con el **orden de herencia** y sobre escrituras de funciones para evitar conflictos.

```javascript
pragma solidity ^0.8.0;

contract Padre1 {
    function decirHola() public pure virtual returns (string memory) {
        return "Hola desde Padre1";
    }
}

contract Padre2 {
    function decirHola() public pure virtual returns (string memory) {
        return "Hola desde Padre2";
    }
}

contract Hijo is Padre1, Padre2 {
    function decirHola() public pure override(Padre1, Padre2) returns (string memory) {
        return "Hola desde Hijo, sobrescribiendo ambos padres";
    }
}
```
El contrato `Hijo` hereda de ambos contratos `Padre1` y `Padre2`.
Como ambas clases tienen una función `decirHola`, `Hijo` debe sobrescribir explícitamente la función de ambos padres usando `override(Padre1, Padre2)`.

## `super` para llamar a la función padre

Cuando sobrescribes una función en un contrato hijo, aún puedes llamar a la versión de esa función en el contrato padre usando la palabra clave `super`.

```javascript
pragma solidity ^0.8.0;

contract Padre {
    function decirHola() public pure virtual returns (string memory) {
        return "Hola desde el Contrato Padre";
    }
}

contract Hijo is Padre {
    function decirHola() public pure override returns (string memory) {
        return string(abi.encodePacked(super.decirHola(), " y Hijo"));
    }
}
```
En este caso, `Hijo` llama a la función `decirHola` del contrato `Padre` usando `super`, y luego agrega su propia lógica.

## Orden de herencia y el problema del "Diamante"

Cuando usas herencia múltiple, es importante tener en cuenta el orden de herencia. Solidity sigue una estrategia llamada **C3 Linearization** para determinar el orden de los contratos padres. Además, debes evitar el **problema del diamante**, que ocurre cuando múltiples padres heredan de un mismo ancestro común.

```javascript
pragma solidity ^0.8.0;

contract A {
    function decirHola() public pure virtual returns (string memory) {
        return "Hola desde A";
    }
}

contract B is A {
    function decirHola() public pure virtual override returns (string memory) {
        return "Hola desde B";
    }
}

contract C is A {
    function decirHola() public pure virtual override returns (string memory) {
        return "Hola desde C";
    }
}

contract D is B, C {
    function decirHola() public pure override(B, C) returns (string memory) {
        return super.decirHola(); // Determina qué "decirHola" se llama
    }
}
```
Aquí, `D` hereda de `B` y `C`, ambos heredando de `A`. Debes especificar claramente cuál de las versiones de `decirHola` deseas utilizar en `D`.
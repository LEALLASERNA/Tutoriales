En Solidity, existen tres formas principales de manejar errores y detener la ejecución del contrato si algo sale mal:

- **`require`**: Se utiliza para validar condiciones de entrada y lanzar errores si la condición no se cumple.
- **`assert`**: Se usa para verificar condiciones internas, donde los errores indican que algo está mal con el contrato mismo.
- **`revert`**: Permite personalizar los errores y revertir la transacción en cualquier punto de la ejecución.

### Uso de `require`

El método `require` se utiliza comúnmente para validar **entradas** o **condiciones externas**. Si la condición no se cumple, `require` revierte la ejecución de la transacción y devuelve el gas restante al remitente.

```javascript
pragma solidity ^0.8.0;

contract ManejoErrores {
    function dividir(uint a, uint b) public pure returns (uint) {
        require(b != 0, "El divisor no puede ser cero");
        return a / b;
    }
}
```
La función verifica que el divisor `b` no sea 0, y si lo es, la transacción se revierte con un mensaje de error "El divisor no puede ser cero".

### Uso de `assert`

`assert` es más severo que `require` y debe usarse para verificar **invariantes internas** del contrato, es decir, situaciones que deberían **nunca** fallar. Si una condición fallida dentro de `assert` ocurre, indica un error serio en el contrato.

```javascript
pragma solidity ^0.8.0;

contract ManejoErrores {
    uint public total = 100;

    function restar(uint valor) public {
        total -= valor;
        assert(total <= 100); // Algo está mal si "total" es mayor que 100
    }
}
```
Aquí, `assert` se usa para asegurarse de que la variable `total` nunca exceda 100, lo que sería un error en la lógica del contrato.

### Uso de `revert`

`revert` es otra forma de manejar errores que permite abortar la ejecución de la transacción y también personalizar el mensaje de error. Generalmente se usa cuando necesitas hacer validaciones más complejas o retornar temprano en función de ciertas condiciones.

```javascript
pragma solidity ^0.8.0;

contract ManejoErrores {
    function transferir(uint monto) public {
        if (monto > 1000) {
            revert("Monto demasiado alto");
        }
        // Código para transferir fondos
    }
}
```
En este caso, `revert` se utiliza para finalizar la ejecución si el monto es demasiado alto, devolviendo un mensaje personalizado.

### Diferencia entre `require` y `assert`

- **`require`** se utiliza cuando se espera que algo venga del **exterior** del contrato (validación de entradas).
- **`assert`** se utiliza para verificar la **lógica interna** del contrato (invariantes internas).

Una transacción fallida debido a un `require` devolverá el gas restante al remitente, mientras que un `assert` consumirá todo el gas, ya que se supone que los errores de `assert` son excepcionales y no deberían ocurrir.

### Mensajes personalizados en `require` y `revert`

Tanto `require` como `revert` permiten agregar un mensaje de error personalizado que será devuelto si ocurre la falla. Esto es útil para que las dApps o los usuarios puedan entender por qué falló una transacción.

```javascript
pragma solidity ^0.8.0;

contract ManejoErrores {
    function validarEdad(uint edad) public pure returns (string memory) {
        require(edad >= 18, "Debes ser mayor de 18");
        return "Acceso permitido";
    }
}
```
El mensaje "Debes ser mayor de 18" será mostrado si la edad ingresada es menor que 18.

### Try/catch con llamadas a otros contratos

Desde Solidity 0.6.0, es posible manejar errores cuando se hacen **llamadas externas** a otros contratos usando **`try/catch`**. Esto es útil para capturar y manejar fallos de contratos externos.

```javascript
pragma solidity ^0.8.0;

contract ContratoExterno {
    function fallo() public pure {
        require(false, "Falló la llamada");
    }
}

contract ManejoErrores {
    ContratoExterno contratoExterno;

    constructor(address _contratoExterno) {
        contratoExterno = ContratoExterno(_contratoExterno);
    }

    function llamarContratoExterno() public returns (string memory) {
        try contratoExterno.fallo() {
            return "Llamada exitosa";
        } catch Error(string memory motivo) {
            return motivo; // Captura el mensaje de error del contrato externo
        } catch {
            return "Error desconocido";
        }
    }
}
```
Aquí, el contrato intenta hacer una llamada al contrato externo y captura cualquier error que ocurra usando `try/catch`.

### Cuando usar cada uno

- **`require`**: Para verificar entradas de funciones o condiciones que dependen de entradas externas.
- **`assert`**: Para garantizar que la lógica interna del contrato sea correcta (invariantes que no deberían romperse).
- **`revert`**: Para manejar errores complejos o para interrumpir la ejecución de una función bajo ciertas condiciones.